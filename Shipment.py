# -*- coding: utf-8 -*-
"""Untitled24.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bJndFtGjaO7-DSVGzlzdnJTdTal2L1TX
"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import GridSearchCV
from sklearn.tree import DecisionTreeClassifier

file_path = '/content/AI ML Internship Training Data.xlsx'
data = pd.ExcelFile(file_path)
df = data.parse('freight_delivery_realistic_data')

df.head()

weather_types = df['Weather Conditions'].unique()
print(weather_types)

df.info()

df.isnull().sum()

df.shape

# If there are missing values in 'Vehicle Type', fill them with the mode
df['Vehicle Type'].fillna(df['Vehicle Type'].mode()[0], inplace=True)

df.isnull().sum()

# Summary statistics
# print(df.describe())

# Distribution of delayed vs. on-time shipments
sns.countplot(x='Delayed', data=df, palette=['skyblue', 'coral'])
plt.show()

# Check for class imbalance
delay_counts = df['Delayed'].value_counts()
print(delay_counts)

sns.set()

sns.countplot(x = 'Weather Conditions', data = df)

sns.countplot(x = 'Weather Conditions', hue = 'Delayed', data = df)

sns.countplot(x = 'Vehicle Type', data = df)

sns.countplot(x = 'Vehicle Type', hue = 'Delayed', data = df)

sns.countplot(x = 'Origin', data = df)

sns.countplot(x = 'Origin', hue = 'Delayed', data = df)

sns.countplot(x = 'Traffic Conditions', data = df)

sns.countplot(x = 'Traffic Conditions', hue = 'Delayed', data = df)

"""If Traffic condition is Moderate or Heavy, then the delivery will be delayed for sure."""

# Calculate min, max, and range of 'Distance (km)'
min_distance = df['Distance (km)'].min()
max_distance = df['Distance (km)'].max()
range_distance = max_distance - min_distance

print(f"Minimum Distance: {min_distance}")
print(f"Maximum Distance: {max_distance}")
print(f"Range of Distance: {range_distance}")

print(df['Origin'].unique())
print(df['Destination'].unique())
print(df['Vehicle Type'].unique())
print(df['Weather Conditions'].unique())
print(df['Traffic Conditions'].unique())

# Create label encoders for categorical variables
le_origin = LabelEncoder()
le_destination = LabelEncoder()
le_vehicle = LabelEncoder()
le_weather = LabelEncoder()
le_traffic = LabelEncoder()

# Apply encoding
df['Origin_Encoded'] = le_origin.fit_transform(df['Origin'])
df['Destination_Encoded'] = le_destination.fit_transform(df['Destination'])
df['Vehicle_Type_Encoded'] = le_vehicle.fit_transform(df['Vehicle Type'])
df['Weather_Encoded'] = le_weather.fit_transform(df['Weather Conditions'])
df['Traffic_Encoded'] = le_traffic.fit_transform(df['Traffic Conditions'])

df.head()

# Select relevant features
features = ['Origin_Encoded', 'Destination_Encoded', 'Vehicle_Type_Encoded',
            'Distance (km)', 'Weather_Encoded', 'Traffic_Encoded']
target = 'Delayed'

X = df[features]
y = df[target]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Initialize the model
lr_model = LogisticRegression(max_iter=1000)

# Train the model
lr_model.fit(X_train, y_train)

# Initialize the model
rf_model = RandomForestClassifier(random_state=42)

# Train the model
rf_model.fit(X_train, y_train)

dt_model = DecisionTreeClassifier(random_state=42)

# Train the model
dt_model.fit(X_train, y_train)

y_pred_lr = lr_model.predict(X_test)

y_pred_rf = rf_model.predict(X_test)

y_pred_dt = dt_model.predict(X_test)

# Evaluation function
def evaluate_model(y_true, y_pred):
    accuracy = accuracy_score(y_true, y_pred)
    precision = precision_score(y_true, y_pred, pos_label='Yes')
    recall = recall_score(y_true, y_pred, pos_label='Yes')
    f1 = f1_score(y_true, y_pred, pos_label='Yes')
    print(f"Accuracy: {accuracy:.4f}")
    print(f"Precision: {precision:.4f}")
    print(f"Recall: {recall:.4f}")
    print(f"F1 Score: {f1:.4f}")

print("Logistic Regression Performance:")
evaluate_model(y_test, y_pred_lr)

print("Random Forest Performance:")
evaluate_model(y_test, y_pred_rf)

print("Decision Tree Performance:")
evaluate_model(y_test, y_pred_dt)

import matplotlib.pyplot as plt
lr_metrics = {'Accuracy': 0.6265, 'Precision': 0.7029, 'Recall': 0.8521, 'F1 Score': 0.7704}
rf_metrics = {'Accuracy': 0.8825, 'Precision': 0.9414, 'Recall': 0.8960, 'F1 Score': 0.9181}
dt_metrics = {'Accuracy': 0.8620, 'Precision': 0.9064, 'Recall': 0.9058, 'F1 Score': 0.9061}


metrics = ['Accuracy', 'Precision', 'Recall', 'F1 Score']
models = ['Logistic Regression', 'Random Forest', 'Decision Tree']

lr_values = [lr_metrics[metric] for metric in metrics]
rf_values = [rf_metrics[metric] for metric in metrics]
dt_values = [dt_metrics[metric] for metric in metrics]

x = range(len(metrics))

plt.figure(figsize=(10, 6))
plt.plot(x, lr_values, marker='o', label='Logistic Regression')
plt.plot(x, rf_values, marker='s', label='Random Forest')
plt.plot(x, dt_values, marker='^', label='Decision Tree')

plt.xticks(x, metrics)
plt.xlabel("Metrics")
plt.ylabel("Values")
plt.title("Comparison of Model Performance")
plt.legend()
plt.grid(True)
plt.show()

